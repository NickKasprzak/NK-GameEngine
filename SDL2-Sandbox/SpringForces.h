#pragma once
#include "ForceGenerator.h"

namespace Funny
{
	/*
	* Spring forces can be used to represent a variety of
	* things beyond just springs, such as non-solid or
	* deformable objects like flags, ropes, or water ripples.
	*
	* Spring-like forces are founded on Hooke's law, telling
	* us that the force exerted by a spring depends entirely
	* on the distance the spring has been compressed or extended
	* from its position at rest and how stiff the spring is.
	* This is represented via the formula:
	*
	* f = -k * dLen
	*
	* where k is the spring constant representing how stiff
	* the spring is and dLen being the change in the spring's
	* length from compression/extension.
	*
	* The delta length is essentially just the difference in
	* length between the spring's resting length and current
	* length, being represented as li and lf respectively.
	*
	* f = -k * (lf - li)
	*
	* Hooke's law also states that the force generated by a
	* spring is felt on both ends of the spring, meaning that
	* two objects connected by a spring will be attracted and
	* repulsed by the same force.
	*
	* In a 2D/3D space, we need to represent our spring force
	* using a position vector. We can quantify our spring beyond
	* a 1D space by using the current position of our object and
	* the position of the end of the spring its been attached to
	* to get a distance vector d. We can replace lf with the
	* magnitude of d to get the compression/extension of the spring
	* based on the position of our object attached to it. We then
	* scale it by d normalized to ensure that the force is being
	* applied in the direction of our object attached to the spring.
	*
	* d = object position - spring position
	* f = -k * (d magnitude - spring resting length) * d normalized
	*
	* Since the force generated is applied to both ends of our
	* spring, if have to apply the generated for to objects
	* attached to both ends of our spring if they both exist.
	* We can do this by either repeating the calculation for the
	* other object, or caching the calculation and applying the
	* inverse to the other side.
	*
	* This lets us generate a spring-like force in a 2D/3D space
	* without being restricted to spring-dependent values. Any
	* kind of interaction that resists deformation will have
	* Hooke's law present in some capacity, generating a spring
	* like force.
	* 
	* In most physics systems, the core system remains generic
	* but is surrounded by many different helper functions and
	* classes to manipulate the generic core of the system so
	* most of the calculations remain abstracted away from the
	* rest of the application. We build the spring generators
	* using this design concept.
	*/

	/*
	* Our first spring is just a simple one using Hooke's law
	* to connect two particles via a "spring", supplying the
	* resting length and stiffness constants.
	* 
	* Since our force generators exist on the basis of being
	* linked to one particle instance, we need to have this
	* spring generator also manage a reference to the particle
	* at the other end of the spring, rather than having the
	* generator manage both particles.
	* 
	* Because of this, we need to have a unique generator for
	* both particles attached to this spring, as our calculation
	* only applies the force to the particle the generator has
	* been attached to.
	*/
	class ParticleSpringGenerator : IForceGenerator
	{
	public:
		ParticleSpringGenerator(Particle* other, float restingLength, float springConstant);
		virtual void generateForce(Particle* particle, float dt);
	private:
		Particle* other;
		float restingLength;
		float springConstant;
	};

	/*
	* Our next spring generator is similar to the first, only
	* difference being that we're attaching it to a fixed
	* position in space rather than to another particle.
	* 
	* The only change really is that we calculate the distance
	* vector using the anchored position rather than the positon
	* of the other particle.
	*/
	class ParticleAnchoredSpring : IForceGenerator
	{
	public:
		ParticleAnchoredSpring(Vector2* anchoredPosition, float restingLength, float springConstant);
		virtual void generateForce(Particle* particle, float dt);
	private:
		Vector2* anchoredPosition;
		float restingLength;
		float springConstant;
	};

	/*
	* A bungee cord is like a spring that only exerts a force when
	* the two objects at both ends of the spring are being pulled
	* away. This means that the objects can get as close together
	* as they like without being seperated, but will be pulled back
	* together if they're pulled too far from resting length.
	* 
	* This implementation uses two particles, but theres nothing
	* stopping us from having a bungee between a particle and an
	* anchored position in world space like above.
	*/
	class ParticleBungee : IForceGenerator
	{
	public:
		ParticleBungee(Particle* other, float restingLength, float springConstant);
		virtual void generateForce(Particle* particle, float dt);
	private:
		Particle* other;
		float restingLength;
		float springConstant;
	};

	/*
	* In real life, the force exerted on an object by bouyancy is
	* equal to the weight of the water that an object displaces
	* by being submerged in it. Thats to say that the more of an
	* object thats submerged underwater, the more bouyancy force
	* that will be applied to it.
	* 
	* Its worth noting that weight isnt the same as mass in physics.
	* Weight is the force applied to an object by gravity, while
	* mass is an objects resistance to acceleration. This isn't
	* at all relevant to this force generator.
	* 
	* Since calculating the exact water displacement based on the
	* volume of any given model our particle has would be far too
	* complex for a generic gameplay scenario, we instead replace
	* the calculations with a generic bouyancy generator using
	* a spring-like force.
	* 
	* Instead of determining submersion and displacement manually
	* through the object's volume, we instead use constants for
	* the force generator. When our object is near the surface of
	* the water, we apply a force to it based on how far it is
	* from the surface and a constant we use to determine how 
	* submerged a object has to be to be considered fully submerged
	* and not submerged at all. If something is beyond the fully
	* submerged threshold, we consider it fully submerged and stop
	* increasing the force applied based on submersion distance.
	* If something is beyond the fully unsubmerged distance, we dont
	* apply a bouyancy force at all. Based on this submersion value,
	* we can get a rough approximation of how much water has been
	* displaced based on a stand-in value for our object's volume.
	* 
	* This can then be used to calculate the weight of the water
	* thats been displaced by the object, which is then used for
	* our force.
	*/
	class ParticleBouyancy : IForceGenerator
	{
	public:
		ParticleBouyancy(float maxSubmersionDepth, float objVolume, float waterDensity, float waterHeight);
		virtual void generateForce(Particle* particle, float dt);
	private:
		float maxSubmersionDepth;
		float objVolume;
		float waterDensity;
		float waterHeight;
	};
}